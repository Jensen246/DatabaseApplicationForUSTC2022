# 数据库实验 银行业务管理系统
PB19030925 李其正

## 概述

构建一个B/S结构的银行业务管理系统，实现系统的前端页面、后台服务器和数据库的设计构建。

## 实验环境

* Win10系统，Pycharm编辑器

* 技术栈：`MySQL`+`Flask`+`Jinja2`+`html`+`css`+`javascript`等，Pycharm相关设置如下：

  * 设置`Settings->Langurages & Frameworks->Flask`勾选`Flask Integration`

  * `Run->Edit Configurations->Flask`打开`FLASK_DEBUG`，从而在程序运行时进入Debug模式

  * 修改项目文件夹下的`idea/BankApplication.iml`可以实现`html`文件中的`jinja2`语法高亮：

    在component标签的同级，添加如下代码：

    ```ini
    <component name="TemplatesService">
    <option name="TEMPLATE_CONFIGURATION" value="Jinja2" />
    <option name="TEMPLATE_FOLDERS">
    <list>
    <option value="$MODULE_DIR$/templates" />
    </list>
    </option>
    </component>
    ```

## 需求描述
### 数据需求
银行有多个支行。各个支行位于某个城市，每个支行有唯一的名字。银行要监控每个支行的资产。银行的客户通过其身份证号来标识。银行存储每个客户的姓名、联系电话以及家庭住址。为了安全起见，银行还要求客户提供一位联系人的信息，包括联系人姓名、手机号、Email 以及与客户的关系。客户可以有帐户，并且可以贷款。客户可能和某个银行员工发生联系，该员工是此客户的贷款负责人或银行帐户负责人。银行员工也通过身份证号来标识。员工分为部门经理和普通员工，每个部门经理都负责领导其所在部门的员工，并且每个员工只允许在一个部门内工作。每个支行的管理机构存储每个员工的姓名、电话号码、家庭地址及部门经理的身份证号。银行还需知道每个员工开始工作的日期，由此日期可以推知员工的雇佣期。银行提供两类帐户——储蓄帐户和支票帐户。帐户可以由多个客户所共有，一个客户也可开设多个账户，但在一个支行内最多只能开设一个储蓄账户和一个支票账户。每个帐户被赋以唯一的帐户号。银行记录每个帐户的余额、开户日期、开户的支行名以及每个帐户所有者访问该帐户的最近日期。另外，每个储蓄帐户有利率和货币类型，且每个支票帐户有透支额。每笔贷款由某个分支机构发放，能被一个或多个客户所共有。每笔贷款用唯一的贷款号标识。银行需要知道每笔贷款所贷金额以及逐次支付的情况（银行将贷款分几次付给客户）。虽然贷款号不能唯一标识银行所有为贷款所付的款项，但可以唯一标识为某贷款所付的款项。对每次的付款需要记录日期和金额。

###  主要功能需求  

* 客户管理：提供客户所有信息的增、删、改、查功能；如果客户存在着关联账户或者贷款记录，则不允许删除；
* 账户管理：提供账户开户、销户、修改、查询功能，包括储蓄账户和支票账户；账户号不允许修改；
* 贷款管理：提供贷款信息的增、删、查功能，提供贷款发放功能；贷款信息一旦添加成功后不允许修改；要求能查询每笔贷款的当前状态（未开始发放、发放中、已全部发放）；处于发放中状态的贷款记录不允许删除；
* 业务统计：按业务分类（储蓄、贷款）和时间（月、季、年）统计各个支行的业务总金额和用户数，统计的结果以表格形式展示  。  
* 说明：
  \2. 后台 DBMS 使用 MySQL；
  \4. 查询功能允许自行设计，但要求尽可能灵活设计，考虑用户多样化的查询需求；
  \5. 各类数据的类型可自行根据实际情况设计；
  \6. 测试数据自行设计；
  \7. 系统实现时要保证数据之间的一致性；
  \8. 程序须有一定的出错处理，要求自己先做好测试，能够处理可以预见的一些错误，例如输入的客户姓名带单引号（类似 O’Neil）、输入数据不合法等等；
  \9. 其余功能可以自行添加，例如登录管理、权限管理等等，但不做强制要求。如果做了添
  加，请在实验报告中加以描述；
  \10. 本实验要求单独完成  

## 系统实现功能设计

* 不要求实现支行、部门和员工信息这三类数据的维护，但在程序开始运行之前需要插入这些数据，用命令行连接MySQL运行`batch_init.sql`即可，登录时将默认编码设置为`utf8`以免出现乱码：

  ```mysql
  mysql -u user -p --default-character-set=utf8
  password:******
  > source batch_init.sql
  ```

  该程序调用了多个sql文件，其中`init_database.sql`用于建库，`init_bank.sql`用于插入支行和部门，`init_employee.sql`用于初始化员工（包括初始化员工的登录用户名密码），`init_customer.sql`用于插入一部分客户和他们的储蓄与支票账户记录

* 主页为登录/注册页面，可以注册新**客户**用户（**不含员工**用户，员工用户信息在初始化sql文件中插入数据库，且只能修改密码，不可修改其他属性），登录用户分为两类：客户和员工，他们的权限区分如下：
  * 客户用户：
    * 客户管理：增、删、改、查自己的信息（如果客户存在关联账户或贷款记录则不允许删除）
    * 账户管理：账户开户、销户、修改，包括储蓄账户和支票账户，账户号不可以修改；新增账户时需要从对应支行的对应部门选择一个员工做自己的账户负责人
    * 贷款管理：贷款信息的增、删、查功能，如果想要删除贷款需要客户提出申请，员工确认后真正删除；贷款信息一旦添加成功便不允许修改；“增”指的是发起贷款，客户发起贷款后贷款状态为“未发放”，由员工发放部分贷款后贷款状态为“发放中”，金额全部发放完后状态改为“已全部发放”；“查”指的是查询该用户每笔贷款的当前状态（未开始发放、发放中、已全部发放）；处于发放中状态的贷款记录不允许删除；新增贷款时需要从对应支行的对应部门选择一个员工做自己的账户负责人
    * 业务统计：用户不可以使用该功能
  * 员工用户：
    * 客户管理：由客户自己操作，员工可以查看所属支行所有客户的个人信息，以及可以根据姓名、地址或联系人姓名中包含的字段模糊搜索客户
    * 账户管理：由客户自己操作，员工可以从客户管理界面查看每个客户的账户，也可以根据姓名或账户号搜索客户
    * 贷款管理：与客户的增、删、查功能相对应，可以确认用户的删除贷款申请，进行发放贷款，也可以根据姓名或贷款号搜索客户
    * 业务统计：按业务分类（储蓄、支票、贷款）和时间（月、季、年）统计各个支行的业务总金额和用户数， 统计的结果以表格形式展示  

## 系统内部设计

### 后端-数据库设计

* 根据实验二的结果设计，根据总体功能设计新增/修改如下属性：
  * 对于员工和客户，为登录功能新增"用户名"和"密码"，且不允许登录系统出现重复用户名，url的构成也大多数使用了用户名，可以理解为实际使用时用作主键的是“用户名”
  * 储蓄账户中的"货币类型"用数字0，1，2，3分别表示人民币、美元、欧元和日元
  * 对于贷款表，新增"贷款发放状态"，用数字0，1，2表示三个状态
  * 对于员工表，新增"Is_Manager"属性，数字1，0分别表示是/不是经理
  * 对于部门表，将主键由"部门ID"改为“（支行，部门ID）”

#### 支行表

存储所有支行账户信息。  

| 属性          | 说明                |
| ------------- | ------------------- |
| Bank_Name     | 主键，支行的名称    |
| Bank_City     | 支行所在城市        |
| Bank_Property | 支行资产，默认值为0 |

```sql
/*==============================================================*/
/* Table: SubBank                                               */
/*==============================================================*/
create table SubBank
(
   Bank_Name            char(32) not null  comment '支行名称',	
   Bank_City            char(32)  comment '支行所在城市',
   Bank_Property        float  DEFAULT 0.0 comment '支行资产',
   primary key (Bank_Name)
);
```

#### 员工表

存储支行员工的信息  

| 属性                 | 说明                               |
| -------------------- | ---------------------------------- |
| Employee_ID          | 主键，员工身份证号码               |
| Department_ID        | 员工所在部门ID                     |
| Employee_Name        | 员工姓名                           |
| Employee_PhoneNumber | 员工电话                           |
| Employee_Address     | 员工家庭住址                       |
| Employee_Enter_Date  | 员工入职日期                       |
| Employee_Username    | 员工账户用户名                     |
| Employee_Password    | 员工账户密码                       |
| Is_Manager           | 经理标识，0表示普通员工，1表示经理 |

```sql
/*==============================================================*/
/* Table: Employee                                              */
/*==============================================================*/
create table Employee
(
   Employee_ID          char(16) not null  comment '员工身份证号码',
   Department_ID        char(32) not null  comment '员工所在部门ID',
   Employee_Name        char(32)  comment '员工姓名',
   Employee_PhoneNumber decimal(12)  comment '员工电话',
   Employee_Address     char(64)  comment '员工家庭住址',
   Employee_Enter_Date  date  comment '员工入职日期',
   Employee_Username	char(16) not null comment '员工账户用户名',
   Employee_Password	char(16) not null comment '员工账户密码',
   Is_Manager			tinyint not null comment '经理标识',
   primary key (Employee_ID)
);
```

#### 客户表

储存所有客户信息

| 属性                      | 说明                 |
| ------------------------- | -------------------- |
| User_ID                   | 主键，客户身份证号码 |
| User_Name                 | 客户姓名             |
| User_PhoneNumber          | 客户电话             |
| User_Address              | 客户家庭地址         |
| User_Contacts_Name        | 联系人姓名           |
| User_Contacts_PhoneNumber | 联系人电话           |
| User_Contacts_Email       | 联系人电子邮件       |
| User_Contacts_Relation    | 客户与联系人关系     |
| User_Username             | 客户账户用户名       |
| User_Password             | 客户账户密码         |

```sql
/*==============================================================*/
/* Table: Customer                                              */
/*==============================================================*/
create table Customer
(
   User_ID              char(16) not null  comment '客户身份证号码',
   User_Name            char(32)  comment '客户姓名',
   User_PhoneNumber     char(16)  comment '客户电话',
   User_Address         char(64)  comment '客户家庭地址',
   User_Contacts_Name   char(32)  comment '联系人姓名',
   User_Contacts_PhoneNumber char(16)  comment '联系人电话',
   User_Contacts_Email  char(32)  comment '联系人电子邮件',
   User_Contacts_Relation char(32)  comment '客户与联系人关系',
   User_Username	char(16) not null comment '员工账户用户名',
   User_Password	char(16) not null comment '员工账户密码',
   primary key (User_ID)
);
```

#### 部门表

存储部门信息，营销部负责储蓄和支票账户，客服部负责贷款

| 属性                  | 说明         |
| --------------------- | ------------ |
| Department_ID         | 部门ID，主键 |
| Bank_Name             | 支行名称     |
| Department_Name       | 部门名称     |
| Department_Type       | 支行类型     |
| Department_Manager_ID | 支行经理ID   |

```sql
/*==============================================================*/
/* Table: Department                                            */
/*==============================================================*/
create table Department
(
   Department_ID        char(32) not null  comment '部门ID',
   Bank_Name            char(32) not null  comment '支行名称',
   Department_Name      char(32)  comment '部门名称',
   Department_Type      char(32)  comment '支行类型',
   Department_Manager_ID char(16) not null  comment '支行经理ID',
   primary key (Department_ID)
);
```

#### ~~账户表~~

即支票账户与储蓄账户的父类，但在实际业务中不需要，故删除

| 属性            | 说明     |
| --------------- | -------- |
| Account_ID      | 账户号   |
| Account_balance | 账户余额 |
| Reg_Date        | 开户日期 |
| Reg_Bank        | 开户支行 |

```sql
/*==============================================================*/
/* Table: Account                                               */
/*==============================================================*/
create table Account
(
   Account_ID           char(32) not null  comment '账户号',
   Account_balance      float  comment '账户余额',
   Reg_Date             date  comment '开户日期',
   Reg_Bank             char(32)  comment '开户支行',
   primary key (Account_ID)
);
```

#### 支票账户表

存储支票账户信息

* 账户号以`ck + 数字`表示，建立新支票账户时数字取数据库中的最大值+1
* 透支额度表示该账户能够超出余额取款的最大额度，也就是说支票账户的余额可以为一个绝对值以透支余额为上限的负值

| 属性            | 说明             |
| --------------- | ---------------- |
| Account_ID      | 主键，支票账户号 |
| Account_balance | 账户余额         |
| Reg_Date        | 开户日期         |
| Reg_Bank        | 开户支行         |
| Overdraft       | 透支额度         |

```sql
/*==============================================================*/
/* Table: CheckAccount                                          */
/*==============================================================*/
create table CheckAccount
(
   Account_ID           char(32) not null  comment '支票账户号',
   Account_balance      float  comment '账户余额',
   Reg_Date             date  comment '开户日期',
   Reg_Bank             char(32)  comment '开户支行',
   Overdraft            float  comment '透支额度',
   primary key (Account_ID)
);
```

#### 储蓄账户表

储存储蓄账户信息 ，账户号以`dp + 数字`表示，建立新储蓄账户时数字取数据库中的最大值+1

| 属性            | 说明                                     |
| --------------- | ---------------------------------------- |
| Account_ID      | 储蓄账户号                               |
| Account_balance | 账户余额                                 |
| Reg_Date        | 开户日期                                 |
| Reg_Bank        | 开户行                                   |
| Interest_Rate   | 利率                                     |
| Currency_type   | 货币类型： 0:人民币 1:美元 2:欧元 3:日元 |

```sql
/*==============================================================*/
/* Table: DepositAccount                                        */
/*==============================================================*/
create table DepositAccount
(
   Account_ID           char(32) not null  comment '储蓄账户号',
   Account_balance      float  comment '账户余额',
   Reg_Date             date  comment '开户日期',
   Reg_Bank             char(32)  comment '开户行',
   Interest_Rate        float  comment '利率',
   Currency_type        int(1)  comment '货币类型',
   primary key (Account_ID)
);
```

#### 贷款表 

存储所有的贷款信息，贷款号以`ln + 数字`的形式表示，建立新贷款时数字取数据库中的最大值+1

| 属性        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| Loan_ID     | 主键，贷款号                                                 |
| Bank_Name   | 发放支行支行名                                               |
| Loan_Money  | 贷款额度                                                     |
| Loan_Status | 发放状态： 0:"未开始发放" 1:"发放中" 2:"已全部发放"，默认为0 |

```sql
/*==============================================================*/
/* Table: Loan                                                  */
/*==============================================================*/
create table Loan
(
   Loan_ID              char(16) not null  comment '贷款号',
   Bank_Name            char(32) not null  comment '发放支行名',
   Loan_Money           float  comment '贷款额度',
   Loan_Status			int(1)	DEFAULT 0 comment '发放状态',
   primary key (Loan_ID)
);
```

#### 支付情况表

存储贷款的支付情况，考虑到一笔贷款可能分多次支付，增加支付日期`Pay_Date`与贷款号`Loan_ID`共同作为主键

| 属性      | 说明                   |
| --------- | ---------------------- |
| Loan_ID   | 主键，支付对应的贷款号 |
| Pay_Date  | 主键，支付日期         |
| Pay_Money | 支付金额               |

```sql
/*==============================================================*/
/* Table: Payment                                               */
/*==============================================================*/
create table Payment
(
   Loan_ID              char(16) not null  comment '支付对应的贷款号',
   Pay_Date             date  comment '支付日期',
   Pay_Money            float  comment '支付金额',
   primary key (Loan_ID,Pay_Date)
);
```

#### 客户-储蓄账户唯一表

用客户-储蓄账户的组合实体和账户做一（账户）对多（组合）的关系映射，以实现”一个用户在一个支行内最多只能开设一个储蓄账户  “

| 属性           | 说明                 |
| -------------- | -------------------- |
| User_ID        | 主键，户主身份证号码 |
| Bank_Name      | 主键，开户支行支行名 |
| Account_ID     | 对应的储蓄账户账户号 |
| Last_View_Date | 最近访问日期         |

```sql
/*==============================================================*/
/* Table: Customer_DepositAccount                               */
/*==============================================================*/
create table Customer_DepositAccount
(
   User_ID              char(16) not null  comment '户主身份证号码',
   Bank_Name            char(32) not null  comment '开户支行支行名',
   Account_ID           char(32) not null  comment '对应的储蓄账户账户号',
   Last_View_Date       date  comment '最近访问日期',
   primary key (User_ID, Bank_Name)
);
```

#### 客户-支票账户唯一表 

与客户-储蓄账户唯一表同理

| 属性           | 说明                 |
| -------------- | -------------------- |
| User_ID        | 主键，户主身份证号码 |
| Bank_Name      | 主键，开户支行支行名 |
| Account_ID     | 对应的支票账户账户号 |
| Last_View_Date | 最近访问日期         |

```sql
/*==============================================================*/
/* Table: Customer_CheckAccount                                 */
/*==============================================================*/
create table Customer_CheckAccount
(
   User_ID              char(16) not null  comment '户主身份证号码',
   Bank_Name            char(32) not null  comment '开户支行支行名',
   Account_ID           char(32) not null  comment '对应的支票账户账户号',
   Last_View_Date       date  comment '最近访问日期',
   primary key (User_ID, Bank_Name)
);
```

#### 客户-贷款表

记录客户和贷款的对应关系

| 属性    | 说明                 |
| ------- | -------------------- |
| Loan_ID | 主键，贷款号         |
| User_ID | 主键，用户身份证号码 |

```sql
/*==============================================================*/
/* Table: Customer_Loan                                         */
/*==============================================================*/
create table Customer_Loan
(
   Loan_ID              char(16) not null  comment '贷款号',
   User_ID              char(16) not null  comment '用户身份证号码',
   primary key (Loan_ID, User_ID)
);
```

#### 员工-客户表

* 服务类型用"ck", "dp", "ln"分别代表支票账户、储蓄账户和贷款业务
* 考虑到设计银行功能时客服部同时负责支票账户和储蓄账户，增加服务类型主键

| 属性         | 说明                 |
| ------------ | -------------------- |
| Employee_ID  | 主键，员工身份证号码 |
| User_ID      | 主键，用户身份证号码 |
| Service_Type | 主键，服务类型       |

```sql
/*==============================================================*/
/* Table: Employee_Customer                                     */
/*==============================================================*/
create table Employee_Customer
(
   Employee_ID          char(16) not null  comment '员工身份证号码',
   User_ID              char(16) not null  comment '用户身份证号码',
   Service_Type         char(32)  comment '服务类型',
   primary key (Employee_ID, User_ID, Service_Type)
);
```

#### 外键约束

使用lab2的pdm文件生成sql代码，并根据数据库的改动作少量修改即可

```sql
alter table CheckAccount add constraint FK_CHECKACC_ACCOUNT_C_ACCOUNT foreign key (Account_ID)
      references Account (Account_ID)   ;

alter table Customer_CheckAccount add constraint FK_CUSTOMER_CHECKACCO_CHECKACC foreign key (Account_ID)
      references CheckAccount (Account_ID) on delete restrict on update restrict;

alter table Customer_CheckAccount add constraint FK_CUSTOMER_CUSTOMER__CUSTOMER foreign key (User_ID)
      references Customer (User_ID) on delete restrict on update restrict;

alter table Customer_CheckAccount add constraint FK_CUSTOMER_SUBBANK_C_SUBBANK foreign key (Bank_Name)
      references SubBank (Bank_Name) on delete restrict on update restrict;

alter table Customer_DepositAccount add constraint FK_CUSTOMER_CUSTOMER__CUSTOMER1 foreign key (User_ID)
      references Customer (User_ID) on delete restrict on update restrict;

alter table Customer_DepositAccount add constraint FK_CUSTOMER_DEPOSITAC_DEPOSITA foreign key (Account_ID)
      references DepositAccount (Account_ID) on delete restrict on update restrict;

alter table Customer_DepositAccount add constraint FK_CUSTOMER_SUBBANK_D_SUBBANK foreign key (Bank_Name)
      references SubBank (Bank_Name) on delete restrict on update restrict;

alter table Customer_Loan add constraint FK_CUSTOMER_CUSTOMER__LOAN foreign key (Loan_ID)
      references Loan (Loan_ID) on delete restrict on update restrict;

alter table Customer_Loan add constraint FK_CUSTOMER_CUSTOMER__CUSTOMER2 foreign key (User_ID)
      references Customer (User_ID) on delete restrict on update restrict;

alter table Department add constraint FK_DEPARTME_SUBBANK_D_SUBBANK foreign key (Bank_Name)
      references SubBank (Bank_Name) on delete restrict on update restrict;

alter table DepositAccount add constraint FK_DEPOSITA_ACCOUNT_D_ACCOUNT foreign key (Account_ID)
      references Account (Account_ID) on delete restrict on update restrict;

alter table Employee add constraint FK_EMPLOYEE_EMPLOYEE__DEPARTME foreign key (Department_ID)
      references Department (Department_ID) on delete restrict on update restrict;

alter table Employee_Customer add constraint FK_EMPLOYEE_EMPLOYEE__EMPLOYEE foreign key (Employee_ID)
      references Employee (Employee_ID) on delete restrict on update restrict;

alter table Employee_Customer add constraint FK_EMPLOYEE_EMPLOYEE__CUSTOMER foreign key (User_ID)
      references Customer (User_ID) on delete restrict on update restrict;

alter table Loan add constraint FK_LOAN_LOAN_SUBB_SUBBANK foreign key (Bank_Name)
      references SubBank (Bank_Name) on delete restrict on update restrict;

alter table Payment add constraint FK_PAYMENT_PAY_LOAN_LOAN foreign key (Loan_ID)
      references Loan (Loan_ID) on delete restrict on update restrict;
```

### 后端-其他设计

#### 登录和注册界面

* 输入合法性问题：

  * 单引号处理：对可能出现单引号的字符串采用字符串替换在单引号前加转义符，比如用户名和密码（其他同理）：

    ```python
    username = username.replace('\'', '\\\'')
    password = password.replace('\'', '\\\'')
    ```

  * 其他合法性问题（如邮箱格式，输入字段的长度和类型等）：注册和修改信息时，采用`WTform`内置的表单认证实现，认证类放在`forms_verify.py`中以供调用


* 安全存储密码

  `Flask`的依赖`Werkzeug`内置了用于生成和验证密码散列值的函数，`werkzeug.security.generate_password_hash()`用来为给定的密码生成密码散列值， 而`werkzeug.security.check_password_hash()`则用来检查给定的散列值和密码是否对应 。使用示例如下所示： 

```python
>>> from werkzeug.security import generate_password_hash, check_password_hash
>>> pw_hash = generate_password_hash('dog') # 为密码 dog 生成密码散列值
>>> pw_hash # 查看密码散列值
'pbkdf2:sha256:50000$mm9UPTRI$ee68ebc71434a4405a28d34ae3f170757fb424663dc0ca15198cb881edc0978f'
>>> check_password_hash(pw_hash, 'dog') # 检查散列值是否对应密码 dog

True
>>> check_password_hash(pw_hash, 'cat') # 检查散列值是否对应密码 cat

False
```

在存储用户信息的 User 模型类添加`username`字段和`password_hash`字段， 分别用来存储登录所需的用户名和密码散列值， 同时添加两个方法来实现设置密码和验证密码的功能。数据库中预先存放的用户名和密码相同，密码为原始非散列值；而注册新用户和修改密码产生的密码则会以散列值形式存储到数据库中。登录时，输入的密码与数据库中存储的字段相同、或是`check_password_hash()`返回`True`均能成功登录，不同的是前者会产生一个修改密码的不安全提醒。

#### 权限管理

如果获知了该管理系统url设置的规则，在不设计权限管理的情况下，只需要在地址栏改变url就可以访问任何想要访问的用户，本系统则利用`flask.session`完成了权限管理。

* Session的概念

  session 是基于cookie实现， 保存在服务端的键值对（形式为 {随机字符串：‘xxxxxx’}）, 同时在浏览器中的cookie中也对应一相同的随机字符串，用来再次请求的 时候验证；对于Flask，session存在浏览器中  默认key是session(加密的cookie)， 也可以像Django一样基于上述的方式实现保存在数据库中

* 具体实现逻辑：有两种方案

  * 方案一

    当客户或员工通过`login_customer.html`或`login_employee.html`页面成功登录时，记录`session['username']`为当前用户名，登出时则用`session.pop('username',None)`删除这一记录，当进入需要登录权限的url时，检验url中的用户名是否和session中相同，若不同则返回未登录的初始界面

    这种方案的缺点是一次只能登录一个用户

  * 方案二

    用`session[username]`存储当前处于登录状态的用户，每次登录成功时设置`session[username]=True`，登出或注销时时通过`session.pop(username)`删除用户名，当进入需要登录权限的url时，检验url中的用户名是否满足`session[username]=True`，若不满足则返回未登录的初始界面

    方案二解决了方案一的缺点，但不知道如果用户A和用户B同时在登录状态，用户A能不能直接进入用户B权限的url。猜想若实际进行部署，每台客户机的session是按照浏览器或IP地址分别维护的，是可以实现权限保护的。

  * 实验过程中一开始采用方案一，后改用方案二，可在[Github](https://github.com/Jensen246/DatabaseApplicationForUSTC2022/commits/main)上查看历史记录

